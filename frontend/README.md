
# Структура проекта (фронтенд)

`app` исходный код приложения

`assets` статический контент: иконки, шрифты

`environments` файлы с параметрами окружения


## Каталог `core`
низкоуровневые сервисы и модели данных: запросы на сервер, управление состоянием, контроллеры и т.д.

`models` модели данных, относящиеся к описанию сущностей для взаимодействии с сервером, DTO

### `core/API`
сервисы взаимодействия с сервером

`client` клиент для работы с запросами на сервер, обработка ошибок

## Каталог  `layout`
корневая компонента приложения с хедером и боковым меню, внутри роутинг вложенных компонент(страниц)

## Каталог  `pages`
страницы приложения (имеют маршруты)

## Каталог  `shared`
компоненты, пайпы, сервисы и т.д., используемые в нескольких частях проекта.
Подразделяется на 2 подпапки: `ui-kit` и `features`.

`ui-kit` содержит расшариваемые компоненты без бизнес-логики.

`features` содержит расшариваемые компоненты, в которых могу быть элементы бизнес-логики, специфичные для данного проекта.

## Каталог  `material`
Эта папка содержит мдуль, в котором реэкспортируются сущности из библиотеки Angular Material, которые используютсяв данном проекте.

## Структура feature-модуля
Структура отдельного feature-модуля состоит из папок:
`components`, `containers`, `data-services`, `children-modules`, `shared`.

Далее описывается содержимое этих папок.
1. 	`components` содержит презентационные компоненты, которые зависят только от @Input и @Output. В эти компоненты не могут инжектироваться сервисы из папки data-services, которые работают с данными.
    Для @Input рекомендуется использоваться Generic ReadonlyDeep, чтобы поддерживать иммутабельность.

2.	`containers` содержить в себе smart-компоненты, которые агрегируют в своем шаблоне компоненты из соответствующей папки `components`. Контейнеры могут содержать зависимости из папки `data-services` для работы с данными. Рекомендуется избегать ручных подписок, передавая данные в презентационные компоненты через async pipe.

Компоненты из папок `containers` и `components` обязательно используют ChangeDetectionStrategy.OnPush.

3.	`data-services` содержит сервисы, предназначенные для получения, обработки и хранения данных конкретного feature-модуля. рекомендуется использовать сервисы, которые наследуются от ngrx component-store.
    Бизнес-логику реализуем в сервисах из папки `data-services`, при этом store сервис является связующим звеном, в котором хранится стейт компонента. В отдельных сервисах могут реализовываться отдельные части логики, однако каждый
    такой сервис не имеет своего состояния (state). В частности, это означает, что эти сервисы не используют локальные члены класса примитивных типов. Используют только Observable и операции rxjs над ними.
    Такой подход необходим для того, чтобы обеспечить отсутствие ручных подписок (subscribe) в компонентах, а также
    исключить необоснованное использование ChangeDetectorRef.

4.	`children-modules` содержит дочерние feature-модули, которые соответствуют дочерним роутам основного feature-модуля. Каждый дочерний feature-модуль починяется той же структуре, что и все feature-модули.


5.	`shared` содержит общие переиспользуемые компоненты. Рекомендуется группировать однотипные сущности в этой папке по папкам: `components`, `directives`, `pipes`, `services` и т.п. Папка `shared` содержит свой модуль, в котором экспортируются все сущности этого модуля.

# Как релизить версию?

Идея, которая заложена в инструкции ниже - повторяет модель ветвления [Git flow](https://nvie.com/posts/a-successful-git-branching-model/).
Перед тем как приступать к выполнению инструкции по релизу версии в нашем репозитории предлагается ознакомиться с общим описанием процесса Git flow  [по ссылке](https://danielkummer.github.io/git-flow-cheatsheet/index.ru_RU.html).

Итак, чтобы создать релиз версии необходимо проделать следующие шаги:

1. Обновляем текущее состояние ветки `develop`:
- `$ git pull origin develop`

2. Создаем релизную ветку от `develop`, называя ее по правилам *release/название проекта + версия*, например, и переключаемся в нее:
- `$ git checkout -b release/ARM_1.2.3`

  p.s. Команда *git checkout -b* сразу переключит в созданную ветку.

3. Пушим релизную ветку на удаленный сервер, например:
- `$ git push origin release/ARM_1.2.3`

4. Далее в релизной ветке могут происходить изменения (например, исправления багов). Все ветки с фиксами также пушатся на удаленный сервер и оформляются через pull request (PR):
- `создание PR fix/12345 -> release/ARM_1.2.3`

5. После того, как все фиксы сделаны, вручную в интерфейсе Gitlab создаем PR из релизной ветки в `main` и `develop`, кратко заполняя информацию о релизе:
- `создание PR release/ARM_1.2.3 -> main`
- `создание PR release/ARM_1.2.3 -> develop`

p.s. Прямые пуши в ветку `main` и `develop` запрещены, изменения проходят только через PR, который требует хотя бы одного approve на ревью

6.  После того как PR одобрен, вручную в интерфейсе Gitlab в форме PR мерджим изменения в `main` и `develop`.

7. Переключаемся в продакшен ветку `main` и помечаем последний релиз-коммит тегом, равным имени релиза c обязательным префиксом `v`, и не забываем пушить теги на удаленный сервер, например:
- `$ git tag vARM_1.2.3`
- `$ git push --tags`

8. После релиза для продакшен-ветки могут понадобиться срочные исправления. Для этого от  `main` или от соответствующего тега ветки `main` ответвляется ветка с исправлением, которую необходимо помечать ключевым словом *hotfix*, например:
- `$ git checkout -b hotfix/12345`

9. Когда исправление готово, оно сливается обратно в ветки `develop` и `main` (создается два PR):
- `создание PR hotfix/12345 -> develop`
- `создание PR hotfix/12345 -> main`

10. Коммит в ветке `main` помечается тегом с версией исправления, инкрементируется третья цифра в версии, имя тега начинается с префикса `v`.

Перед созданием тега можно забрать к себе актуальные и посмотреть, какой номер хотфикса следующий, например:
- `$ git fetch --tags`
- `$ git tag -l`

  `vARM_1.2.0`

  `vARM_1.2.1`

  `vARM_1.2.2`

- `$ git tag vARM_1.2.3`
- `$ git push --tags`

  p.s. Не забываем пушить теги на удаленный сервер.
